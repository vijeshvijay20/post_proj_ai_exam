{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "31766f37",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Copyright 2019 The TensorFlow Authors All Rights Reserved.\n",
    "#\n",
    "# Licensed under the Apache License, Version 2.0 (the \"License\");\n",
    "# you may not use this file except in compliance with the License.\n",
    "# You may obtain a copy of the License at\n",
    "#\n",
    "#     http://www.apache.org/licenses/LICENSE-2.0\n",
    "#\n",
    "# Unless required by applicable law or agreed to in writing, software\n",
    "# distributed under the License is distributed on an \"AS IS\" BASIS,\n",
    "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
    "# See the License for the specific language governing permissions and\n",
    "# limitations under the License.\n",
    "# ==============================================================================\n",
    "\n",
    "\"\"\"Feature computation for YAMNet.\"\"\"\n",
    "\n",
    "import numpy as np\n",
    "import tensorflow as tf\n",
    "\n",
    "\n",
    "def waveform_to_log_mel_spectrogram(waveform, params):\n",
    "  \"\"\"Compute log mel spectrogram of a 1-D waveform.\"\"\"\n",
    "  with tf.name_scope('log_mel_features'):\n",
    "    # waveform has shape [<# samples>]\n",
    "\n",
    "    # Convert waveform into spectrogram using a Short-Time Fourier Transform.\n",
    "    # Note that tf.signal.stft() uses a periodic Hann window by default.\n",
    "    window_length_samples = int(\n",
    "      round(params.SAMPLE_RATE * params.STFT_WINDOW_SECONDS))\n",
    "    hop_length_samples = int(\n",
    "      round(params.SAMPLE_RATE * params.STFT_HOP_SECONDS))\n",
    "    fft_length = 2 ** int(np.ceil(np.log(window_length_samples) / np.log(2.0)))\n",
    "    num_spectrogram_bins = fft_length // 2 + 1\n",
    "    magnitude_spectrogram = tf.abs(tf.signal.stft(\n",
    "        signals=waveform,\n",
    "        frame_length=window_length_samples,\n",
    "        frame_step=hop_length_samples,\n",
    "        fft_length=fft_length))\n",
    "    # magnitude_spectrogram has shape [<# STFT frames>, num_spectrogram_bins]\n",
    "\n",
    "    # Convert spectrogram into log mel spectrogram.\n",
    "    linear_to_mel_weight_matrix = tf.signal.linear_to_mel_weight_matrix(\n",
    "        num_mel_bins=params.MEL_BANDS,\n",
    "        num_spectrogram_bins=num_spectrogram_bins,\n",
    "        sample_rate=params.SAMPLE_RATE,\n",
    "        lower_edge_hertz=params.MEL_MIN_HZ,\n",
    "        upper_edge_hertz=params.MEL_MAX_HZ)\n",
    "    mel_spectrogram = tf.matmul(\n",
    "      magnitude_spectrogram, linear_to_mel_weight_matrix)\n",
    "    log_mel_spectrogram = tf.math.log(mel_spectrogram + params.LOG_OFFSET)\n",
    "    # log_mel_spectrogram has shape [<# STFT frames>, MEL_BANDS]\n",
    "\n",
    "    return log_mel_spectrogram\n",
    "\n",
    "\n",
    "def spectrogram_to_patches(spectrogram, params):\n",
    "  \"\"\"Break up a spectrogram into a stack of fixed-size patches.\"\"\"\n",
    "  with tf.name_scope('feature_patches'):\n",
    "    # Frame spectrogram (shape [<# STFT frames>, MEL_BANDS]) into patches \n",
    "    # (the input examples).\n",
    "    # Only complete frames are emitted, so if there is less than \n",
    "    # PATCH_WINDOW_SECONDS of waveform then nothing is emitted \n",
    "    # (to avoid this, zero-pad before processing).\n",
    "    hop_length_samples = int(\n",
    "      round(params.SAMPLE_RATE * params.STFT_HOP_SECONDS))\n",
    "    spectrogram_sr = params.SAMPLE_RATE / hop_length_samples\n",
    "    patch_window_length_samples = int(\n",
    "      round(spectrogram_sr * params.PATCH_WINDOW_SECONDS))\n",
    "    patch_hop_length_samples = int(\n",
    "      round(spectrogram_sr * params.PATCH_HOP_SECONDS))\n",
    "    features = tf.signal.frame(\n",
    "        signal=spectrogram,\n",
    "        frame_length=patch_window_length_samples,\n",
    "        frame_step=patch_hop_length_samples,\n",
    "        axis=0)\n",
    "    # features has shape [<# patches>, <# STFT frames in an patch>, MEL_BANDS]\n",
    "\n",
    "    return features"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
