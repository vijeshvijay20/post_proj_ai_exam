{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7a5ed7a5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Copyright 2019 The TensorFlow Authors All Rights Reserved.\n",
    "#\n",
    "# Licensed under the Apache License, Version 2.0 (the \"License\");\n",
    "# you may not use this file except in compliance with the License.\n",
    "# You may obtain a copy of the License at\n",
    "#\n",
    "#     http://www.apache.org/licenses/LICENSE-2.0\n",
    "#\n",
    "# Unless required by applicable law or agreed to in writing, software\n",
    "# distributed under the License is distributed on an \"AS IS\" BASIS,\n",
    "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
    "# See the License for the specific language governing permissions and\n",
    "# limitations under the License.\n",
    "# ==============================================================================\n",
    "\n",
    "\"\"\"Core model definition of YAMNet.\"\"\"\n",
    "\n",
    "import csv\n",
    "\n",
    "import numpy as np\n",
    "import tensorflow as tf\n",
    "from tensorflow.keras import Model, layers\n",
    "\n",
    "import yamnet.features as features_lib\n",
    "import yamnet.params as params\n",
    "\n",
    "\n",
    "def _batch_norm(name):\n",
    "  def _bn_layer(layer_input):\n",
    "    return layers.BatchNormalization(\n",
    "      name=name,\n",
    "      center=params.BATCHNORM_CENTER,\n",
    "      scale=params.BATCHNORM_SCALE,\n",
    "      epsilon=params.BATCHNORM_EPSILON)(layer_input)\n",
    "  return _bn_layer\n",
    "\n",
    "\n",
    "def _conv(name, kernel, stride, filters):\n",
    "  def _conv_layer(layer_input):\n",
    "    output = layers.Conv2D(name='{}/conv'.format(name),\n",
    "                           filters=filters,\n",
    "                           kernel_size=kernel,\n",
    "                           strides=stride,\n",
    "                           padding=params.CONV_PADDING,\n",
    "                           use_bias=False,\n",
    "                           activation=None)(layer_input)\n",
    "    output = _batch_norm(name='{}/conv/bn'.format(name))(output)\n",
    "    output = layers.ReLU(name='{}/relu'.format(name))(output)\n",
    "    return output\n",
    "  return _conv_layer\n",
    "\n",
    "\n",
    "def _separable_conv(name, kernel, stride, filters):\n",
    "  def _separable_conv_layer(layer_input):\n",
    "    output = layers.DepthwiseConv2D(name='{}/depthwise_conv'.format(name),\n",
    "                                    kernel_size=kernel,\n",
    "                                    strides=stride,\n",
    "                                    depth_multiplier=1,\n",
    "                                    padding=params.CONV_PADDING,\n",
    "                                    use_bias=False,\n",
    "                                    activation=None)(layer_input)\n",
    "    output = _batch_norm(name='{}/depthwise_conv/bn'.format(name))(output)\n",
    "    output = layers.ReLU(name='{}/depthwise_conv/relu'.format(name))(output)\n",
    "    output = layers.Conv2D(name='{}/pointwise_conv'.format(name),\n",
    "                           filters=filters,\n",
    "                           kernel_size=(1, 1),\n",
    "                           strides=1,\n",
    "                           padding=params.CONV_PADDING,\n",
    "                           use_bias=False,\n",
    "                           activation=None)(output)\n",
    "    output = _batch_norm(name='{}/pointwise_conv/bn'.format(name))(output)\n",
    "    output = layers.ReLU(name='{}/pointwise_conv/relu'.format(name))(output)\n",
    "    return output\n",
    "  return _separable_conv_layer\n",
    "\n",
    "\n",
    "_YAMNET_LAYER_DEFS = [\n",
    "    # (layer_function, kernel, stride, num_filters)\n",
    "    (_conv,          [3, 3], 2,   32),\n",
    "    (_separable_conv, [3, 3], 1,   64),\n",
    "    (_separable_conv, [3, 3], 2,  128),\n",
    "    (_separable_conv, [3, 3], 1,  128),\n",
    "    (_separable_conv, [3, 3], 2,  256),\n",
    "    (_separable_conv, [3, 3], 1,  256),\n",
    "    (_separable_conv, [3, 3], 2,  512),\n",
    "    (_separable_conv, [3, 3], 1,  512),\n",
    "    (_separable_conv, [3, 3], 1,  512),\n",
    "    (_separable_conv, [3, 3], 1,  512),\n",
    "    (_separable_conv, [3, 3], 1,  512),\n",
    "    (_separable_conv, [3, 3], 1,  512),\n",
    "    (_separable_conv, [3, 3], 2, 1024),\n",
    "    (_separable_conv, [3, 3], 1, 1024)\n",
    "]\n",
    "\n",
    "\n",
    "def yamnet(features):\n",
    "  \"\"\"Define the core YAMNet mode in Keras.\"\"\"\n",
    "  net = layers.Reshape(\n",
    "    (params.PATCH_FRAMES, params.PATCH_BANDS, 1),\n",
    "    input_shape=(params.PATCH_FRAMES, params.PATCH_BANDS))(features)\n",
    "  for (i, (layer_fun, kernel, stride, filters)) in enumerate(_YAMNET_LAYER_DEFS):\n",
    "    net = layer_fun('layer{}'.format(i + 1), kernel, stride, filters)(net)\n",
    "  net = layers.GlobalAveragePooling2D()(net)\n",
    "  logits = layers.Dense(units=params.NUM_CLASSES, use_bias=True)(net)\n",
    "  predictions = layers.Activation(\n",
    "    name=params.EXAMPLE_PREDICTIONS_LAYER_NAME,\n",
    "    activation=params.CLASSIFIER_ACTIVATION)(logits)\n",
    "  return predictions\n",
    "\n",
    "\n",
    "def yamnet_frames_model(feature_params):\n",
    "  \"\"\"Defines the YAMNet waveform-to-class-scores model.\n",
    "\n",
    "  Args:\n",
    "    feature_params: An object with parameter fields to control the feature\n",
    "    calculation.\n",
    "\n",
    "  Returns:\n",
    "    A model accepting (1, num_samples) waveform input and emitting a\n",
    "    (num_patches, num_classes) matrix of class scores per time frame as\n",
    "    well as a (num_spectrogram_frames, num_mel_bins) spectrogram feature\n",
    "    matrix.\n",
    "  \"\"\"\n",
    "  waveform = layers.Input(batch_shape=(1, None))\n",
    "  # Store the intermediate spectrogram features to use in visualization.\n",
    "  spectrogram = features_lib.waveform_to_log_mel_spectrogram(\n",
    "    tf.squeeze(waveform, axis=0), feature_params)\n",
    "  patches = features_lib.spectrogram_to_patches(spectrogram, feature_params)\n",
    "  predictions = yamnet(patches)\n",
    "  frames_model = Model(name='yamnet_frames', \n",
    "                       inputs=waveform, outputs=[predictions, spectrogram])\n",
    "  return frames_model\n",
    "\n",
    "\n",
    "def class_names(class_map_csv):\n",
    "  \"\"\"Read the class name definition file and return a list of strings.\"\"\"\n",
    "  with open(class_map_csv) as csv_file:\n",
    "    reader = csv.reader(csv_file)\n",
    "    next(reader)   # Skip header\n",
    "    return np.array([display_name for (_, _, display_name) in reader])"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
